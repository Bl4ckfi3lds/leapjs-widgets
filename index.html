<!DOCTYPE HTML>
<html>
<head>
  <title>Bone Hands - Leap</title>
  <script src="javascripts/three.r67.js"></script>
  <script src="javascripts/lib/physi.js"></script>
  <script src="javascripts/leap-0.6.1.min.js"></script>
  <script src="javascripts/leap-plugins-0.1.6.min.js"></script>
  <script src="javascripts/lib/TrackballControls.js"></script>
</head>
<body>

  <script>
    var baseBoneRotation = (new THREE.Quaternion).setFromEuler(
        new THREE.Euler(Math.PI / 2, 0, 0)
    );
    var BUTTON_COLOR = 0xf000ff;
    var BUTTON_COLOR_ACTIVE = 0xff0000;

    Leap.loop({background: true}, {
      hand: function (hand) {

        hand.fingers.forEach(function (finger) {

          finger.data('boneMeshes').forEach(function(mesh, i){
            var bone = finger.bones[i];
            var bonePosition = new THREE.Vector3().fromArray(bone.center());
            bonePosition.y -= 150;
            mesh.setLinearVelocity(bonePosition.sub(mesh.position).multiplyScalar(16));
            mesh.setRotationFromMatrix(new THREE.Matrix4().fromArray(bone.matrix()));
            mesh.quaternion.multiply(baseBoneRotation);
            mesh.__dirtyRotation = true;
          });

          finger.data('jointMeshes').forEach(function(mesh, i){
            var bone = finger.bones[i];
            var jointPosition = new THREE.Vector3().fromArray(bone ? bone.prevJoint : finger.bones[i-1].nextJoint);
            jointPosition.y -= 150;
            mesh.setLinearVelocity(jointPosition.sub(mesh.position).multiplyScalar(20));
            mesh.setAngularVelocity(new THREE.Vector3());
          });

        });
    }})
      // these two LeapJS plugins, handHold and handEntry are available from leapjs-plugins, included above.
      // handHold provides hand.data
      // handEntry provides handFound/handLost events.
    .use('handHold')
    .use('handEntry')
    .on('handFound', function(hand){
      hand.fingers.forEach(function (finger, fingerIndex) {

        var boneMeshes = [];
        var jointMeshes = [];

        finger.bones.forEach(function(bone, boneIndex) {
          var boneMesh = new Physijs.CylinderMesh(
              new THREE.CylinderGeometry(bone.width/2, bone.width/2, bone.length - bone.width),
              Physijs.createMaterial(new THREE.MeshPhongMaterial(), 0, 0),
              100
          );
          // TODO: why does the thumb have this extra bone? Removing it
          if (boneIndex === 0 && fingerIndex === 0) {
            boneMesh.visible = false;
            boneMesh.mass = 0;
          }
          boneMesh.castShadow = true;
          scene.add(boneMesh);
          boneMeshes.push(boneMesh);
        });

        for (var i = 0; i < finger.bones.length + 1; i++) {
          var jointMesh = new Physijs.SphereMesh(
              new THREE.SphereGeometry((finger.bones[i] || finger.bones[i-1]).width/2, 16),
              Physijs.createMaterial(new THREE.MeshPhongMaterial(), 0, 0),
              100
          );
          jointMesh.castShadow = true;
          if (i === 0 && fingerIndex === 0) {
            jointMesh.visible = false;
            jointMesh.mass = 0;
          }

          jointMesh.material.color.setHex(0x0088ce);
          scene.add(jointMesh);
          jointMeshes.push(jointMesh);
        }


        finger.data('boneMeshes', boneMeshes);
        finger.data('jointMeshes', jointMeshes);

      });

    })
    .on('handLost', function(hand){

      hand.fingers.forEach(function (finger) {

        var boneMeshes = finger.data('boneMeshes');
        var jointMeshes = finger.data('jointMeshes');

        boneMeshes.forEach(function(mesh){
          scene.remove(mesh);
        });

        jointMeshes.forEach(function(mesh){
          scene.remove(mesh);
        });

        finger.data({
          boneMeshes: null,
          boneMeshes: null
        });

      });
    })
//    .use('playback', {
//      // This is a compressed JSON file of preprecorded frame data
//      recording: 'recordings/scroll-and-swipe-100fps.json.lz',
//      // How long, in ms, between repeating the recording.
//      timeBetweenLoops: 2000,
//      pauseOnHand: true
//    })
    .connect();


    function createLabel(text, x, y, z, size, color, backGroundColor, backgroundMargin) {
      if(!backgroundMargin)
        backgroundMargin = 50;

      var canvas = document.createElement("canvas");

      var context = canvas.getContext("2d");
      context.font = size + "pt Arial";

      var textWidth = context.measureText(text).width;

      canvas.width = textWidth + backgroundMargin;
      canvas.height = size + backgroundMargin;
      context = canvas.getContext("2d");
      context.font = size + "pt Arial";

      if(backGroundColor) {
        context.fillStyle = backGroundColor;
        context.fillRect(canvas.width / 2 - textWidth / 2 - backgroundMargin / 2, canvas.height / 2 - size / 2 - +backgroundMargin / 2, textWidth + backgroundMargin, size + backgroundMargin);
      }

      context.textAlign = "center";
      context.textBaseline = "middle";
      context.fillStyle = color;
      context.fillText(text, canvas.width / 2, canvas.height / 2);

      // context.strokeStyle = "black";
      // context.strokeRect(0, 0, canvas.width, canvas.height);

      var texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;

      var material = new THREE.MeshBasicMaterial({
        map : texture
      });

      var mesh = new THREE.Mesh(new THREE.PlaneGeometry(canvas.width, canvas.height), material);
      // mesh.overdraw = true;
      mesh.doubleSided = true;
      mesh.position.x = x - canvas.width;
      mesh.position.y = y - canvas.height;
      mesh.position.z = z;

      return mesh;
    }

    function createButton(position, dimensions) {
      var button = new Physijs.BoxMesh(
        new THREE.BoxGeometry(dimensions.x, dimensions.y, dimensions.z),
        Physijs.createMaterial(new THREE.MeshPhongMaterial({
          color: BUTTON_COLOR
        }), 1, 0.9),
        100
      );
      button.originalposition = position;
      button.position.copy(button.originalposition);
      button.receiveShadow = true;
      button.castShadow = true;
      scene.add(button);

      button.slider = new Physijs.SliderConstraint(
        button,
        null,
        new THREE.Vector3(0, 0, -200),
        new THREE.Vector3(0, Math.sqrt(2), Math.sqrt(2))
      );
      scene.addConstraint(button.slider);
      button.slider.setLimits(-15, 0, 0, 0);
//      button.slider.setRestitution(0, 0);
      return button;
    }

    var initScene = function () {
      Physijs.scripts.worker = 'javascripts/lib/physijs_worker.js';
      window.scene = new Physijs.Scene();
      window.scene.addEventListener('update', function() {
        scene.simulate( undefined, 2 );
      });
      window.scene.setGravity({x:0,y:-100,z:0});
      window.renderer = new THREE.WebGLRenderer({
        alpha: true
      });
      window.renderer.shadowMapEnabled = true;
      window.renderer.shadowMapType = THREE.BasicShadowMap;


      window.renderer.setClearColor(0x000000, 0);
      window.renderer.setSize(window.innerWidth, window.innerHeight);

      window.renderer.domElement.style.position = 'fixed';
      window.renderer.domElement.style.top = 0;
      window.renderer.domElement.style.left = 0;
      window.renderer.domElement.style.width = '100%';
      window.renderer.domElement.style.height = '100%';

      document.body.appendChild(window.renderer.domElement);


      scene.table = createButton(new THREE.Vector3(0, 0, -150), new THREE.Vector3(100, 100, 30));

      [
       [0, scene.table.position.y + 300, 0],
       [0, scene.table.position.y + 100, scene.table.position.z + 300]
      ].forEach(function(pos) {
        var directionalLight = new THREE.SpotLight(0xffffff, 1);
//        directionalLight.shadowCameraVisible = true;
        directionalLight.castShadow = true;
        directionalLight.shadowMapWidth = 6048;
        directionalLight.shadowMapHeight = 6048;
        directionalLight.shadowCameraLeft = -300;
        directionalLight.shadowCameraRight = 300;
        directionalLight.shadowCameraTop = 300;
        directionalLight.shadowCameraBottom = 300;
        directionalLight.shadowCameraFar = 800;
        directionalLight.shadowDarkness = 0.5;
        directionalLight.position.fromArray(pos);
        scene.add(directionalLight);
      });

      window.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
      window.camera.position.fromArray([0, 0, 200]);
      window.camera.lookAt(new THREE.Vector3(scene.table.position.x, scene.table.position.y, scene.table.position.z));
      window.controls = new THREE.TrackballControls( camera );
      window.controls.target = new THREE.Vector3().fromArray([scene.table.position.x, scene.table.position.y, scene.table.position.z]);

      window.addEventListener('resize', function () {
        controls.handleResize();
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.render(scene, camera);
      }, false);

      scene.add(camera);
    };

    initScene();
    window.step = function() {
      controls.update();

      scene.table.setLinearVelocity(new THREE.Vector3().copy(scene.table.originalposition).sub(scene.table.position).multiplyScalar(16));
      scene.table.material.color.setHex(scene.table.position.z+2 < scene.table.originalposition.z ? BUTTON_COLOR_ACTIVE : BUTTON_COLOR);
      scene.simulate();
      renderer.render(scene, camera);
      requestAnimationFrame(step);
    }
    step();
  </script>

</body>
</html>